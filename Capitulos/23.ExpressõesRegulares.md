# Expressões Regulares

**Expressões regulares** são um mecanismo muito poderoso para manipulação de **strings**, também conhecido como **regex** ou **regexp**, é um campo de estudo muito abrangente na **ciência da computação teórica** e **linguagens formais**. 

Pode-se dizer que é uma sequência de caracteres que define um padrão de busca, normalmente este padrão é usado por algoritmos de busca de strings, onde é feito uma busca por determinado padrão, seja para encontrá-lo ou até mesmo encontrá-lo e alterá-lo, também é muito usado para *validação de input de dados*. 

O conceito surgiu na década de 1950, quando o matemático americano [Stephen Cole Kleene](https://en.wikipedia.org/wiki/Stephen_Cole_Kleene) formalizou a descrição de uma [linguagem regular](https://en.wikipedia.org/wiki/Regular_language). O conceito entrou em uso comum com utilitários de processamento de texto do Unix. Diferentes sintaxes para escrever expressões regulares existem desde a década de 1980, sendo uma o padrão [POSIX](https://en.wikipedia.org/wiki/POSIX) e outra, amplamente utilizada, a sintaxe [Perl](https://en.wikipedia.org/wiki/Perl).

Expressões regulares são usadas em [search engines](https://en.wikipedia.org/wiki/Search_engine), *search and replace dialogs* de processadores de texto e editores de texto, em utilitários de processamento de texto como [sed](https://en.wikipedia.org/wiki/Sed) e [AWK](https://en.wikipedia.org/wiki/AWK) e em análise lexical. Muitas linguagens de programação fornecem recursos de regex integrados ou por meio de bibliotecas, como é o caso da linguagem Python que nos oferece a biblioteca [re](https://docs.python.org/3/library/re.html).

## Introdução

Uma expressão regular, geralmente chamada de padrão, especifica um conjunto de strings necessárias para um propósito específico. Uma maneira simples de especificar um conjunto finito de strings é listar seus elementos ou membros. No entanto, muitas vezes existem maneiras mais concisas, por exemplo, o conjunto contendo as três cadeias de caracteres "Handel", "Händel" e "Haendel" pode ser especificado pelo padrão `H(ä|ae?)Ndel`, dizemos que esse padrão corresponde a cada uma das três strings. Na maioria dos formalismos, se existe pelo menos uma expressão regular que corresponde a um determinado conjunto, então existe um número infinito de outras expressões regulares que também correspondem a ela - a especificação não é única.

**Âncoras**: `^` e `$`

| Exemplo  | Descrição                                      | URL                                |
|----------|------------------------------------------------|------------------------------------|
| ^Py      | Encontra qualquer string que comece com Py      | **https://regex101.com/r/cO8lqs/4303** |
| on$      | Encontra uma string que termina com on          | **https://regex101.com/r/cO8lqs/4304** |
| ^Python$ | Encontra a string Python                       | **https://regex101.com/r/cO8lqs/4305** |
| Python   | Encontra qualquer string que tenha Python em si | **https://regex101.com/r/cO8lqs/23892**                                    |

**Quantificadores**: `*`, `+`, `?` e `{}`

| Exemplo    | Descrição                                                                           |
|------------|-------------------------------------------------------------------------------------|
| abc*       | Encontra uma string que tenha ab seguido por zero ou mais c                          |
| abc+       | Encontra uma string que tenha ab seguido por um ou mais c                            |
| abc?       | Encontra uma string que tenha ab seguido por zero, ou um c                           |
| abc{2}     | Encontra uma string que tenha ab seguido por dois c                                  |
| abc{2,}    | Encontra uma string que tenha ab seguido por dois ou mais c                          |
| abc{2,5}   | Encontra uma string que tenha ab seguido por 2 até no máximo 5 c                     |
| a(bc)*     | Encontra uma string que tenha a seguido por zero ou mais cópias da sequência bc      |
| a(bc){2,5} | Encontra uma string que tenha a seguido por 2 até no máximo 5 cópias da sequência bc |

**Operador OU**: `|` e `[]`

| Exemplo | Descrição                                                                         |
|---------|-----------------------------------------------------------------------------------|
| a(b\|c)  | Encontra uma string que tenha a seguido por b ou c                                 |
| a[bc]   | Igual o anterior, ambas as notações podem ser usadas e produzem o mesmo resultado |

**Classes de caracteres**: `\d`, `\w`, `\s` e `.`

| Exemplo | Descrição                                                               |
|---------|-------------------------------------------------------------------------|
| \d      | Encontra um único caracter que seja um dígito                            |
| \w      | Encontra um caracter de palavra (caracter alfanumérico e underline)      |
| \s      | Encontra caracteres de espaço em branco (incluindo tabs e quebra de linha) |
| .       | Encontra qualquer caracter                                               |

**Negação de classe de caracteres**: `\D`, `\W`, `\S`

| Exemplo | Descrição                                                 |
|---------|-----------------------------------------------------------|
| \D      | Faz a operação inversa de \d e traz todos os não-dígitos  |
| \W      | Faz a operação inversa de \w e traz todas as não-palavras |
| \S      | Faz a operação inversa de \s e traz todos os não-espaços  |

Outro ponto importante, é caso queiramos dar **escape**, por exemplo validar um `.`, para isso usamos o `\.`

O mesmo vale caso seja necessário validarmos `$`, utilizamos `\$`

Experimente mais opções de expressões em **[Regex101](https://regex101.com/r/cO8lqs/1)**

## Expressões Regulares em Python

Python já possui incluído o módulo **re** que utilizaremos para nossas **expressões regulares**, este módulo fornece operações de correspondência de expressões regulares semelhantes às encontradas em Perl.

Para usá-lo precisamos importá-lo, sem a necessidade de instalação, vamos também inspecionar o módulo para termos uma visão do que ele nos disponibiliza em termos de atributos e métodos.

```python
import re

print(dir(re)) 
# ['A', 'ASCII', 'DEBUG', 'DOTALL', 'I', 'IGNORECASE', 'L', 'LOCALE', 'M', 'MULTILINE', 'S', 'Scanner', 'T', 'TEMPLATE', 'U', 'UNICODE', 'VERBOSE', 'X', '_MAXCACHE', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '__version__', '_alphanum_bytes', '_alphanum_str', '_cache', '_cache_repl', '_compile', '_compile_repl', '_expand', '_locale', '_pattern_type', '_pickle', '_subx', 'compile', 'copyreg', 'error', 'escape', 'findall', 'finditer', 'fullmatch', 'match', 'purge', 'search', 'split', 'sre_compile', 'sre_parse', 'sub', 'subn', 'sys', 'template']
```

Veja que temos bastantes opções, inicialmente vamos ver os métodos **findall()**, **split()**, **search()** e **match()**.

#### findall()

```python
import re

x = "Expressões regulares são legais"
r = re.findall(r"\w+", x)
print(r) # ['Expressões', 'regulares', 'são', 'legais']
```

Como podemos ver, todos os caracteres da sentença foram correspondidos e recebemos uma lista deles.

#### split()

```python
import re

e = "Eu sou uma expressao com diversas palavras"
r = re.split(r'\s', e)
print(r) # ['Eu', 'sou', 'uma', 'expressao', 'com', 'diversas', 'palavras']
```

Como podemos ver, a função **split()** separou a expressao em diversos valores, usando o separador `\s` que representa espaço em branco.

#### search()

```python
import re

padrao = "a*b"
r = re.search(padrao, "aaaaaaabcedefg")
print(r) # <_sre.SRE_Match object; span=(0, 8), match='aaaaaaab'>
print(r.group()) # aaaaaaab
```

Como podemos ver, primeiro nos foi retornado um **objeto match**, posteriormente acessamos a string encontrada através do método **group()** que nos traz o resultado, também podemos aplicar os métodos **start()**, **end()** e **span()**.

#### match()

Neste exemplo vamos usar um padrão simples para darmos **match** em um email:

```python
import re

padrao = "\w+@(\w+\.)+(com|org|net)" # 
r = re.match(padrao, "teste@teste.org")
print(r.group()) # teste@teste.org
```

Vimos que nesse caso, foi possível dar match no e-mail `teste@teste.org`, nos mostrando assim a relevância e importância das expressões regulares dentro da computação, um assunto relevante e de compreensão necessária, pois está presente em praticamente todas as linguagens de programação e sua aplicabilidade é muito vasta.